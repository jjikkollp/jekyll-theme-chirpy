---
title: CF1481Div2
date: 2021-02-02 19:00:00 +0800
categories: [Toturial, CF]
tags: [dp]
math: true
---

### E

> 给一个数组，每次操作可以把一个数字移到最右边，问最少操作多少次能让数组中一样的数字都在一起，如2211333。

注意到操作顺序是任意的，我们只要决定哪些数字要移到最右边就行了。那么问题就变成了，最多留下多少个数字，他们是符合要求的。

那么我们从左到右dp，如果当前位置是某种数字的最右边，那么我们考虑将所有这种数字留下，$dp[i]=dp[l[a[i]]-1]+cnt[a[i]]$，这是$[1,i]$的答案，加上右边，我们取右边出现次数最多的数，把他们留下。

```c++
const int N=5e5+10;
int n,a[N],mxr[N],l[N],r[N],cnt[N],dp[N];
inline void wk(){
    n=read();
    rep(i,1,n) a[i]=read();
    rpe(i,n,1){
        ++cnt[a[i]];
        mxr[i]=mxr[i+1];
        chmax(mxr[i],cnt[a[i]]);
        l[a[i]]=i;
        chmax(r[a[i]],i);
    }
    int ans=0;
    rep(i,1,n){
        dp[i]=dp[i-1];
        if(r[a[i]]==i){
            chmax(dp[i],dp[l[a[i]]-1]+cnt[a[i]]);
            chmax(ans,dp[i]+mxr[i+1]);
        }
    }
    printf("%d\n",n-ans);
}
```
